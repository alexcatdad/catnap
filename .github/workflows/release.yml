# .github/workflows/release.yml
#
# Automatic release on merge to main.
# Parses conventional commits since the last tag to determine semver bump:
#   - "feat:" -> minor
#   - "fix:", "perf:", "refactor:" -> patch
#   - "!:" or "BREAKING CHANGE" -> major
#   - "docs:", "ci:", "chore:", "test:", "style:" -> skip (no release)
#
# Tags the commit, builds a signed .app bundle, and publishes a GitHub release.

name: Release

on:
  push:
    branches: [main]
    tags: ['v*']

permissions:
  contents: write

jobs:
  release:
    name: Build & Release
    runs-on: macos-15
    if: github.actor != 'github-actions[bot]' || !startsWith(github.ref, 'refs/tags/')
    outputs:
      tag: ${{ steps.version.outputs.tag }}
      released: ${{ steps.version.outputs.skip != 'true' }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        env:
          HEAD_MESSAGE: ${{ github.event.head_commit.message }}
        run: |
          # If triggered by a tag push, use the tag directly
          if [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            echo "tag=${GITHUB_REF#refs/tags/}" >> "$GITHUB_OUTPUT"
            echo "skip=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Skip non-release commits
          if echo "$HEAD_MESSAGE" | head -1 | grep -qE '^(docs|ci|chore|test|style)(\(.+\))?:'; then
            echo "Non-release commit type. Skipping."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Get the latest tag
          LATEST_TAG=$(git tag -l 'v*' --sort=-v:refname | head -n1)
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v0.0.0"
          fi

          # Parse current version
          VERSION="${LATEST_TAG#v}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Get commits since last tag
          COMMITS=$(git log "$LATEST_TAG"..HEAD --pretty=format:"%s" 2>/dev/null || git log --pretty=format:"%s")
          echo "Commits since $LATEST_TAG:"
          echo "$COMMITS"

          # Determine bump type
          BUMP="none"
          while IFS= read -r msg; do
            if echo "$msg" | grep -qE '^[a-z]+(\(.+\))?!:' || echo "$msg" | grep -qi 'BREAKING CHANGE'; then
              BUMP="major"
              break
            fi
            if echo "$msg" | grep -qE '^feat(\(.+\))?:'; then
              [ "$BUMP" != "major" ] && BUMP="minor"
            fi
            if echo "$msg" | grep -qE '^(fix|perf|refactor)(\(.+\))?:'; then
              [ "$BUMP" = "none" ] && BUMP="patch"
            fi
          done <<< "$COMMITS"

          if [ "$BUMP" = "none" ]; then
            echo "No version-bumping commits found. Skipping."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          case "$BUMP" in
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
            patch) PATCH=$((PATCH + 1)) ;;
          esac

          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          echo "tag=$NEW_TAG" >> "$GITHUB_OUTPUT"
          echo "skip=false" >> "$GITHUB_OUTPUT"
          echo "Bumping $BUMP: $LATEST_TAG -> $NEW_TAG"

      - name: Create tag
        if: steps.version.outputs.skip != 'true' && !startsWith(github.ref, 'refs/tags/')
        env:
          NEW_TAG: ${{ steps.version.outputs.tag }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
          git push origin "$NEW_TAG"

      - name: Inject version into Info.plist
        if: steps.version.outputs.skip != 'true'
        env:
          TAG: ${{ steps.version.outputs.tag }}
        run: |
          VERSION="${TAG#v}"
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $VERSION" SupportFiles/Info.plist
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" SupportFiles/Info.plist

      - name: Build release
        if: steps.version.outputs.skip != 'true'
        run: swift build -c release

      - name: Bundle .app
        if: steps.version.outputs.skip != 'true'
        run: |
          mkdir -p Catnap.app/Contents/MacOS
          cp .build/release/Catnap Catnap.app/Contents/MacOS/Catnap
          cp SupportFiles/Info.plist Catnap.app/Contents/Info.plist
          codesign --force --sign - Catnap.app

      - name: Zip .app
        if: steps.version.outputs.skip != 'true'
        run: ditto -c -k --keepParent Catnap.app Catnap.app.zip

      - name: Create release
        if: steps.version.outputs.skip != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          files: Catnap.app.zip
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  update-homebrew:
    name: Update Homebrew Tap
    runs-on: ubuntu-latest
    needs: release
    if: needs.release.outputs.released == 'true'
    environment: action-runners
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_SECRET }}
          owner: ${{ github.repository_owner }}
          repositories: homebrew-tap

      - name: Get GitHub App user ID
        id: get-user-id
        run: echo "user-id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Download release artifact
        run: gh release download "$TAG" --repo "$REPO" --pattern 'Catnap.app.zip' --dir assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.release.outputs.tag }}
          REPO: ${{ github.repository }}

      - name: Compute SHA256 checksum
        id: sha
        run: echo "sha256=$(sha256sum assets/Catnap.app.zip | cut -d' ' -f1)" >> "$GITHUB_OUTPUT"

      - name: Extract version
        id: version
        run: echo "version=${TAG#v}" >> "$GITHUB_OUTPUT"
        env:
          TAG: ${{ needs.release.outputs.tag }}

      - name: Checkout homebrew-tap
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/homebrew-tap
          token: ${{ steps.app-token.outputs.token }}

      - name: Update cask
        env:
          VERSION: ${{ steps.version.outputs.version }}
          SHA256: ${{ steps.sha.outputs.sha256 }}
        run: |
          mkdir -p Casks
          cat > Casks/catnap.rb << EOF
          cask "catnap" do
            version "${VERSION}"
            sha256 "${SHA256}"

            url "https://github.com/alexcatdad/catnap/releases/download/v#{version}/Catnap.app.zip"
            name "Catnap"
            desc "macOS menubar dashboard for local git repos"
            homepage "https://github.com/alexcatdad/catnap"

            app "Catnap.app"

            zap trash: "~/.config/catnap"
          end
          EOF

      - name: Update README
        env:
          OWNER: ${{ github.repository_owner }}
        run: |
          TABLE="| Formula | Version | Description |\n|---------|---------|-------------|"
          for rb in Formula/*.rb; do
            name=$(basename "$rb" .rb)
            ver=$(grep -m1 'version "' "$rb" | sed 's/.*version "//;s/".*//')
            desc=$(grep -m1 'desc "' "$rb" | sed 's/.*desc "//;s/".*//')
            TABLE="${TABLE}\n| [${name}](https://github.com/${OWNER}/${name}) | ${ver} | ${desc} |"
          done
          if [ -d Casks ]; then
            for rb in Casks/*.rb; do
              name=$(basename "$rb" .rb)
              ver=$(grep -m1 'version "' "$rb" | sed 's/.*version "//;s/".*//')
              desc=$(grep -m1 'desc "' "$rb" | sed 's/.*desc "//;s/".*//')
              TABLE="${TABLE}\n| [${name}](https://github.com/${OWNER}/${name}) | ${ver} | ${desc} (cask) |"
            done
          fi

          INSTALL="\`\`\`bash\n"
          for rb in Formula/*.rb; do
            name=$(basename "$rb" .rb)
            INSTALL="${INSTALL}brew install ${OWNER}/tap/${name}\n"
          done
          if [ -d Casks ]; then
            for rb in Casks/*.rb; do
              name=$(basename "$rb" .rb)
              INSTALL="${INSTALL}brew install --cask ${OWNER}/tap/${name}\n"
            done
          fi
          INSTALL="${INSTALL}\`\`\`"

          awk -v table="$TABLE" -v install="$INSTALL" '
            /<!-- BEGIN FORMULAE -->/ { print; printf "%s\n", table; skip=1; next }
            /<!-- END FORMULAE -->/ { skip=0 }
            skip { next }
            /<!-- BEGIN INSTALL -->/ { print; printf "%s\n", install; skip2=1; next }
            /<!-- END INSTALL -->/ { skip2=0 }
            skip2 { next }
            { print }
          ' README.md > README.tmp && mv README.tmp README.md

      - name: Commit and push
        env:
          VERSION: ${{ steps.version.outputs.version }}
          APP_SLUG: ${{ steps.app-token.outputs.app-slug }}
          USER_ID: ${{ steps.get-user-id.outputs.user-id }}
        run: |
          git config user.name "${APP_SLUG}[bot]"
          git config user.email "${USER_ID}+${APP_SLUG}[bot]@users.noreply.github.com"
          git add Casks/catnap.rb README.md
          git diff --staged --quiet || {
            git commit -m "chore: update catnap to ${VERSION}"
            git push
          }
